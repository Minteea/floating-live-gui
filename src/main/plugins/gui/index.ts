import { app, BrowserWindow, IpcMain, ipcMain, webContents } from "electron";
import {
  AppCommandMap,
  AppEventDetail,
  BasePlugin,
  FloatingLive,
  PluginContext,
} from "floating-live";
import path from "path";
import { fileURLToPath } from "node:url";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const GUI_VITE_DEV_SERVER_URL: string;
declare const GUI_VITE_NAME: string;

const __dirname = path.dirname(fileURLToPath(import.meta.url));

declare module "floating-live" {
  interface AppCommandMap {
    devtools: () => void;
    [name: `${string}.snapshot`]: () => any;
  }
}

interface FLEGWebContents extends Electron.WebContents {
  send(channel: "event", eventName: string, detail: AppEventDetail<any>): void;
}

interface FLEGIpcMain extends IpcMain {
  handle(
    channel: "command",
    listener: (
      e: Electron.IpcMainInvokeEvent,
      command: string,
      ...args: any[]
    ) => Promise<[boolean, any]>
  ): void;
  handle(
    channel: "connect",
    listener: (
      e: Electron.IpcMainInvokeEvent,
      connectOptions: { snapshots: string[] }
    ) => [boolean]
  ): void;
}

export default class ElectronGui extends BasePlugin {
  static pluginName = "electronGui";
  mainWindow: BrowserWindow | null = null;
  readonly app: Electron.App = app;

  init(ctx: PluginContext) {
    // init app

    app.whenReady().then(() => {
      this.createMainWindow();
    });
    app.on("window-all-closed", () => {
      if (process.platform !== "darwin") {
        app.quit();
      }
    });
    app.on("activate", () => {
      if (BrowserWindow.getAllWindows().length === 0) {
        this.createMainWindow();
      }
    });

    // init ipcMain

    // 处理连接，连接成功后返回快照信息
    (ipcMain as FLEGIpcMain).handle(
      "connect",
      (e, { snapshots }: { snapshots: string[] }) => {
        const allSnapshots: Record<string, any> = {};
        snapshots.forEach((name) => {
          try {
            allSnapshots[name] = ctx.call(`${name}.snapshot`);
          } catch (e) {}
        });
        e.sender.send("snapshot", allSnapshots);
        return [true];
      }
    );

    // 处理指令
    (ipcMain as FLEGIpcMain).handle(
      "command",
      async <T extends keyof AppCommandMap>(
        e: Electron.IpcMainInvokeEvent,
        command: string,
        ...args: any[]
      ) => {
        try {
          const result = await ctx.call<T>(
            command as T,
            ...(args as Parameters<AppCommandMap[T]>)
          );
          return [true, result];
        } catch (err) {
          let rej;
          if (err instanceof Error) {
            rej = Object.assign(
              { message: err.message, name: err.name, _error: true },
              err
            );
          } else {
            rej = err;
          }
          return [false, rej];
        }
      }
    );

    // 发送事件
    ctx.on("event", (event) => {
      webContents.getAllWebContents().forEach((e: FLEGWebContents) => {
        e.send("event", event.name, event.detail);
      });
    });

    this.ctx.registerCommand("devtools", () => {
      this.mainWindow?.webContents.openDevTools();
    });
  }
  createMainWindow() {
    console.log(path.join(__dirname, "preload.mjs"));
    if (this.mainWindow) return;
    const mainWindow = new BrowserWindow({
      height: 600,
      width: 800,
      titleBarStyle: "hidden",
      titleBarOverlay: {
        color: "#FFFFFF00",
      },
      webPreferences: {
        preload: path.join(__dirname, "preload.mjs"),
        webSecurity: false,
        sandbox: false,
      },
    });
    if (GUI_VITE_DEV_SERVER_URL) {
      mainWindow.loadURL(GUI_VITE_DEV_SERVER_URL);
      console.log(GUI_VITE_DEV_SERVER_URL);
    } else {
      mainWindow.loadFile(
        path.join(__dirname, `../renderer/${GUI_VITE_NAME}/index.html`)
      );
    }
    mainWindow.on("close", () => {
      this.mainWindow = null;
    });
    this.mainWindow = mainWindow;
  }
}
